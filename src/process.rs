use std::{
    cell::{RefCell, RefMut},
    collections::HashMap,
    ffi::c_void,
    marker::PhantomData,
    mem::MaybeUninit,
    num::NonZeroU64,
    ptr::NonNull,
    rc::Rc,
    time::Duration,
};

use crate::{
    sys::{self, library},
    ClientHandle, Error, Frames, OwnedPortUuid, PortFlags, PortType, Time, Transport, Uuid,
};

/// A scope for performing operations in the process thread.
///
/// This object is passed to implementations of [`ProcessHandler`](crate::ProcessHandler). Its
/// methods are a subset of JACK operations that are all guaranteed to be real-time-safe.
#[derive(Debug)]
pub struct ProcessScope<'scope, PortData> {
    pub(crate) client: &'scope ClientHandle,
    pub(crate) ports: &'scope mut ProcessPorts<PortData>,
    pub(crate) nframes: u32,
}

impl<'scope, PortData> ProcessScope<'scope, PortData> {
    /// Returns the number of frames that should be processed in this process cycle.
    ///
    /// Will always be a power of two and will always be equal to
    /// [`Client::buffer_size`](crate::Client::buffer_size). Audio buffers returned by
    /// [`ProcessPort::audio_in_buffer`] and [`ProcessPort::audio_out_buffer`] will be of this
    /// size.
    #[inline]
    pub fn nframes(&self) -> u32 {
        self.nframes
    }
    /// Returns the precise time at the start of the current process cycle.
    ///
    /// This method can be used to interpret timestamps generated by
    /// [`Client::frame_time`](crate::Client::frame_time) in other threads with respect to the
    /// current process cycle.
    ///
    /// This is the only JACK time function that returns exact time: when used during the process
    /// callback it always returns the same value (until the next process callback, where it will
    /// return that value + nframes, etc). The return value is guaranteed to be monotonic and
    /// linear in this fashion unless an xrun occurs. If an xrun occurs, clients must check this
    /// value again, as time may have advanced in a non-linear way (e.g. cycles may have been
    /// skipped).
    #[doc(alias = "jack_last_frame_time")]
    #[inline]
    pub fn last_frame_time(&self) -> Frames {
        Frames(unsafe { self.client.lib.jack_last_frame_time(self.client.as_ptr()) })
    }
    /// Returns the sample rate of the JACK system, as set by the user when the server was started.
    #[doc(alias = "jack_get_sample_rate")]
    pub fn sample_rate(&self) -> u32 {
        unsafe { self.client.lib.jack_get_sample_rate(self.client.as_ptr()) }
    }
    /// Provides the internal cycle timing information as used by most of the other time related
    /// functions.
    ///
    /// This allows the caller to map between frame counts and microseconds with full precision
    /// (i.e. without rounding frame times to integers), and also provides e.g. the microseconds
    /// time of the start of the current cycle directly (it has to be computed otherwise).
    ///
    /// See [`CycleTimes`] for a description of the fields returned.
    #[doc(alias = "jack_get_cycle_times")]
    #[inline]
    pub fn cycle_times(&self) -> crate::Result<CycleTimes> {
        let mut current_frames = 0;
        let mut current_usecs = 0;
        let mut next_usecs = 0;
        let mut period_usecs = 0.;
        let ret = unsafe {
            self.client.lib.jack_get_cycle_times(
                self.client.as_ptr(),
                &mut current_frames,
                &mut current_usecs,
                &mut next_usecs,
                &mut period_usecs,
            )
        };
        Error::check_ret(ret)?;
        Ok(CycleTimes {
            current_frames: Frames(current_frames),
            current_time: Time(current_usecs),
            next_time: Time(next_usecs),
            period: Duration::from_secs_f64(period_usecs as f64 * 1_000_000.),
        })
    }
    /// Returns a object that can used to control the JACK transport.
    #[inline]
    pub fn transport(&self) -> Transport {
        Transport::new(self.client)
    }
    /// Returns an iterator for each owned, registered port.
    ///
    /// The ports are returned in an unspecified order. Clients that only perform I/O in one
    /// direction may be able to process all ports with one simple iteration; clients that perform
    /// both input and output will want to call this method twice, once to only process the input
    /// ports, and then a second time to process the output ports.
    ///
    /// More advanced clients needing a specific order may want to avoid using this method, and
    /// instead store control and routing data atomically in the struct implementing
    /// [`ProcessHandler`](crate::ProcessHandler) using port UUIDs. Then, call
    /// [`Self::port_by_owned_uuid`] on the ports in order.
    #[inline]
    pub fn ports(&'scope self) -> impl Iterator<Item = ProcessPort<'scope, PortData>> + '_ {
        self.ports.ports.values().map(|port| ProcessPort {
            port: &*port.0,
            scope: self,
        })
    }
    /// Looks up a port by UUID.
    ///
    /// Returns `None` if `port` is not registered.
    #[inline]
    pub fn port_by_owned_uuid(
        &'scope self,
        port: OwnedPortUuid,
    ) -> Option<ProcessPort<'scope, PortData>> {
        self.ports.ports.get(&port).map(|port| ProcessPort {
            port: &*port.0,
            scope: self,
        })
    }
    /// Returns the C pointer corresponding to the scope's client.
    #[inline]
    pub fn client_ptr(&self) -> NonNull<sys::jack_client_t> {
        self.client.client
    }
    /// Returns the dynamically loaded JACK library currently used by the scope's client.
    #[inline]
    pub fn library(&self) -> &sys::Jack {
        self.client.lib
    }
}

/// An owned port accessible from [`ProcessScope`].
#[derive(Debug)]
pub struct ProcessPort<'scope, PortData> {
    port: &'scope ProcessPortInner<PortData>,
    scope: &'scope ProcessScope<'scope, PortData>,
}

impl<'scope, PortData> ProcessPort<'scope, PortData> {
    /// Returns the 64-bit unique ID of the port.
    #[doc(alias = "jack_port_uuid")]
    pub fn uuid(&self) -> Uuid {
        let uuid = unsafe {
            NonZeroU64::new_unchecked(self.scope.client.lib.jack_port_uuid(self.as_ptr().as_ptr()))
        };
        Uuid(uuid)
    }
    /// Returns the type ID of this port.
    #[doc(alias = "jack_port_type_id")]
    #[inline]
    pub fn type_id(&self) -> PortType {
        self.port.ptr.port_type
    }
    /// Returns the flags used to register the port.
    #[doc(alias = "jack_port_flags")]
    #[inline]
    pub fn flags(&self) -> PortFlags {
        self.port.ptr.flags
    }
    /// Returns the port data registered with this port.
    ///
    /// The port data is stored in a [`RefCell`], which can safely be read or written to by
    /// [`ProcessHandler`](crate::ProcessHandler) implementations.
    ///
    /// See [`ProcessHandler::PortData`](crate::ProcessHandler::PortData) for a description of how
    /// to use port data.
    #[inline]
    pub fn data(&self) -> &RefCell<PortData> {
        &self.port.data
    }
    /// Returns a buffer containing audio samples sent to this port for the current frame period.
    ///
    /// The buffer length will be equal to the number of frames returned by
    /// [`ProcessScope::nframes`].
    ///
    /// # Panics
    ///
    /// Panics if port is not an audio input port.
    #[doc(alias = "jack_port_get_buffer")]
    pub fn audio_in_buffer(&self) -> &[f32] {
        assert!(self.port.ptr.flags.is_input() && self.port.ptr.port_type == PortType::Audio);
        unsafe {
            let buf = self
                .scope
                .client
                .lib
                .jack_port_get_buffer(self.as_ptr().as_ptr(), self.scope.nframes);
            std::slice::from_raw_parts(buf as *const f32, self.scope.nframes as usize)
        }
    }
    /// Returns a buffer for writing audio samples for the current frame period.
    ///
    /// The buffer length will be equal to the number of frames returned by
    /// [`ProcessScope::nframes`].
    ///
    /// # Panics
    ///
    /// Panics if port is not an audio output port, or if the buffer is still locked by a previous
    /// [`RefMut`] returned from this method.
    #[doc(alias = "jack_port_get_buffer")]
    pub fn audio_out_buffer(&self) -> RefMut<[f32]> {
        assert!(self.port.ptr.flags.is_output() && self.port.ptr.port_type == PortType::Audio);
        let refmut = self.port.buffer_lock.borrow_mut();
        let slice = unsafe {
            let buf = self
                .scope
                .client
                .lib
                .jack_port_get_buffer(self.as_ptr().as_ptr(), self.scope.nframes);
            std::slice::from_raw_parts_mut(buf as *mut f32, self.scope.nframes as usize)
        };
        RefMut::map(refmut, |_| slice)
    }
    /// Returns a buffer containing MIDI events sent to this port for the current frame period.
    ///
    /// # Panics
    ///
    /// Panics if port is not a MIDI input port.
    #[doc(alias = "jack_port_get_buffer")]
    pub fn midi_in_buffer(&self) -> MidiInput {
        assert!(self.port.ptr.flags.is_input() && self.port.ptr.port_type == PortType::Midi);
        let port_buffer = unsafe {
            NonNull::new_unchecked(
                self.scope
                    .client
                    .lib
                    .jack_port_get_buffer(self.as_ptr().as_ptr(), self.scope.nframes),
            )
        };
        MidiInput {
            port_buffer,
            client: PhantomData,
        }
    }
    /// Returns a buffer for writing MIDI events for the current frame period.
    ///
    /// # Panics
    ///
    /// Panics if port is not a MIDI output port, or if
    /// the buffer is still locked by a previous [`RefMut`] returned from this method.
    #[doc(alias = "jack_port_get_buffer")]
    pub fn midi_out_buffer(&self) -> RefMut<MidiWriter> {
        assert!(self.port.ptr.flags.is_output() && self.port.ptr.port_type == PortType::Midi);
        let refmut = self.port.buffer_lock.borrow_mut();
        let port_buffer = unsafe {
            let ptr = NonNull::new_unchecked(
                self.scope
                    .client
                    .lib
                    .jack_port_get_buffer(self.as_ptr().as_ptr(), self.scope.nframes),
            );
            self.scope.client.lib.jack_midi_clear_buffer(ptr.as_ptr());
            ptr
        };

        RefMut::map(refmut, |_| unsafe { std::mem::transmute(port_buffer) })
    }
    /// Returns the C pointer corresponding to this port.
    #[inline]
    pub fn as_ptr(&self) -> NonNull<sys::jack_port_t> {
        self.port.ptr.port
    }
}

/// A single MIDI event packet.
#[doc(alias = "_jack_midi_event")]
#[doc(alias = "jack_midi_event_t")]
#[derive(Debug)]
pub struct MidiEvent<'p> {
    /// Sample index at which the event is valid. Should be less than the value of `nframes` for
    /// the current frame period.
    pub time: u32,
    /// Raw MIDI data. Should be normalised with no running status bytes.
    pub data: &'p [u8],
}

/// A handle to the MIDI event input buffer that can be iterated, or accessed by index.
#[repr(transparent)]
#[derive(Debug)]
pub struct MidiInput<'p> {
    port_buffer: NonNull<c_void>,
    client: PhantomData<&'p ClientHandle>,
}

impl<'p> MidiInput<'p> {
    /// Returns the number of MIDI events in a port buffer.
    #[doc(alias = "jack_midi_get_event_count")]
    pub fn len(&self) -> u32 {
        unsafe { library().jack_midi_get_event_count(self.port_buffer.as_ptr()) }
    }
    /// Returns `true` if the event buffer has <code>[len](Self::len)\() == 0</code>.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    #[inline]
    unsafe fn buffer_get<'e>(
        port_buffer: NonNull<c_void>,
        event_index: u32,
    ) -> std::io::Result<MidiEvent<'e>> {
        let mut event = MaybeUninit::uninit();
        let ret =
            library().jack_midi_event_get(event.as_mut_ptr(), port_buffer.as_ptr(), event_index);
        if ret < 0 {
            return Err(std::io::Error::from_raw_os_error(-ret));
        }
        let event = event.assume_init();
        Ok(MidiEvent {
            time: event.time,
            data: std::slice::from_raw_parts(event.buffer, event.size as usize),
        })
    }
    /// Get a single MIDI event from an event port buffer.
    ///
    /// JACK MIDI is normalised, the MIDI event returned by this method is guaranteed to be a
    /// complete MIDI event (the status byte will always be present, and no real-time events will
    /// interspersed with the event).
    ///
    /// This rule does not apply to System Exclusive MIDI messages since they can be of arbitrary
    /// length. To maintain smooth real-time operation such events CAN be delivered as multiple,
    /// non-normalised events. The maximum size of one event "chunk" depends on the MIDI backend in
    /// use. For example the midiseq driver will create chunks of 256 bytes. The first SysEx
    /// "chunked" event starts with `0xF0` and the last delivered chunk ends with `0xF7`. To
    /// receive the full SysEx message, a caller of `get` must concatenate chunks until a chunk
    /// ends with `0xF7`.
    #[doc(alias = "jack_midi_event_get")]
    pub fn get(&self, event_index: u32) -> std::io::Result<MidiEvent> {
        unsafe { Self::buffer_get(self.port_buffer, event_index) }
    }
    /// Returns the number of events that could not be written to the port buffer.
    ///
    /// This method returning a non-zero value implies the port buffer is full. Currently the only
    /// way this can happen is if events are lost on port mixdown.
    #[doc(alias = "jack_midi_get_lost_event_count")]
    pub fn lost_event_count(&self) -> u32 {
        unsafe { library().jack_midi_get_lost_event_count(self.port_buffer.as_ptr()) }
    }
    /// Returns an iterator for the MIDI events in this buffer.
    pub fn iter(&self) -> MidiInputIter {
        MidiInputIter {
            port_buffer: self.port_buffer,
            index: 0,
            len: self.len(),
            client: PhantomData,
        }
    }
}

impl<'p> IntoIterator for MidiInput<'p> {
    type Item = MidiEvent<'p>;
    type IntoIter = MidiInputIter<'p>;
    fn into_iter(self) -> Self::IntoIter {
        MidiInputIter {
            port_buffer: self.port_buffer,
            index: 0,
            len: self.len(),
            client: PhantomData,
        }
    }
}

/// An [`Iterator`] implementation for [`MidiEvent`]s stored in an input port buffer.
#[derive(Debug)]
pub struct MidiInputIter<'p> {
    port_buffer: NonNull<c_void>,
    index: u32,
    len: u32,
    client: PhantomData<&'p ClientHandle>,
}

impl<'p> Iterator for MidiInputIter<'p> {
    type Item = MidiEvent<'p>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.index >= self.len {
            return None;
        }
        let event = unsafe { MidiInput::buffer_get(self.port_buffer, self.index) }.ok()?;
        self.index += 1;
        Some(event)
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        let hint = (self.len - self.index) as usize;
        (hint, Some(hint))
    }
}

impl<'p> std::iter::DoubleEndedIterator for MidiInputIter<'p> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len == 0 {
            return None;
        }
        let event = unsafe { MidiInput::buffer_get(self.port_buffer, self.len - 1) }.ok()?;
        self.len -= 1;
        Some(event)
    }
}

impl<'p> std::iter::FusedIterator for MidiInputIter<'p> {}
impl<'p> std::iter::ExactSizeIterator for MidiInputIter<'p> {}

/// A helper for writing MIDI events into output port buffers.
#[repr(transparent)]
#[derive(Debug)]
pub struct MidiWriter<'p> {
    port_buffer: NonNull<c_void>,
    client: PhantomData<&'p ClientHandle>,
}

impl<'p> MidiWriter<'p> {
    /// Returns the size of the largest event that can be stored by the port.
    ///
    /// This method returns the current space available, taking into account events already stored
    /// in the port.
    #[doc(alias = "jack_midi_max_event_size")]
    pub fn max_event_size(&self) -> usize {
        unsafe { library().jack_midi_max_event_size(self.port_buffer.as_ptr()) as usize }
    }
    /// Returns the number of events that could not be written to the port buffer.
    ///
    /// This method returning a non-zero value implies the port buffer is full. Currently the only
    /// way this can happen is if events are lost on port mixdown.
    #[doc(alias = "jack_midi_get_lost_event_count")]
    pub fn lost_event_count(&self) -> u32 {
        unsafe { library().jack_midi_get_lost_event_count(self.port_buffer.as_ptr()) }
    }
    /// Write an event into an event port buffer.
    ///
    /// Clients must write normalised MIDI data to the port — no running status and no (1-byte)
    /// real-time messages interspersed with other messages (real-time messages are fine when they
    /// occur on their own, like other messages).
    ///
    /// Events must be written in order, sorted by their sample offsets. JACK will not sort the
    /// events for you, and will refuse to store out-of-order events.
    ///
    /// Returns `Err` if there's not enough space in the buffer for the event.
    #[doc(alias = "jack_midi_event_write")]
    pub fn write(&self, time: u32, event: &MidiEvent) -> std::io::Result<()> {
        let ret = unsafe {
            library().jack_midi_event_write(
                self.port_buffer.as_ptr(),
                time,
                event.data.as_ptr(),
                event.data.len() as _,
            )
        };
        if ret < 0 {
            return Err(std::io::Error::from_raw_os_error(-ret));
        }
        Ok(())
    }
}

/// Times returned by [`ProcessScope::cycle_times`].
///
/// Because of the types used, all the values are unsigned. In computations mapping between frames
/// and microseconds, *signed* differences are required. The easiest way is to compute those
/// separately and assign them to the appropriate signed variables, [`i32`] for frames and [`i64`]
/// for microseconds. See the underlying C implementation of
/// [`Client::frames_to_time`](crate::Client::frames_to_time) and
/// [`Client::time_to_frames`](crate::Client::time_to_frames) for an example.
///
/// Unless there was an xrun, skipped cycles, or the current cycle is the first after
/// freewheeling or starting JACK, the value of `current_time` will always be the value of
/// `next_time` of the previous cycle.
///
/// The value of `period` will in general *not* be exactly equal to the difference of
/// `next_time` and `current_time`. This is because to ensure stability of the DLL and
/// continuity of the mapping, a fraction of the loop error must be included in `next_time`.
/// For an accurate mapping between frames and microseconds, the difference of `next_time` and
/// `current_time` should be used, and not `period`.
#[derive(Debug)]
pub struct CycleTimes {
    /// The frame time counter at the start of the current cycle, same as
    /// [`ProcessScope::last_frame_time`].
    pub current_frames: Frames,
    /// The [`Time`] at the start of the current cycle, with microsecond accuracy.
    pub current_time: Time,
    /// The [`Time`] of the start of the next next cycle as computed by the DLL, with microsecond
    /// accuracy.
    pub next_time: Time,
    /// The current best estimate of the period time as a [`Duration`], with microsecond accuracy.
    pub period: Duration,
}

#[derive(Debug)]
pub(crate) struct ProcessPortOuter<PortData>(pub Rc<ProcessPortInner<PortData>>);

impl<PortData> ProcessPortOuter<PortData> {
    pub fn new(ptr: PortPtr, data: PortData) -> Self {
        Self(Rc::new(ProcessPortInner {
            ptr,
            data: RefCell::new(data),
            buffer_lock: Default::default(),
        }))
    }
}

impl<PortData> Clone for ProcessPortOuter<PortData> {
    #[inline]
    fn clone(&self) -> Self {
        debug_assert_eq!(std::thread::current().id(), self.0.ptr.thread);
        Self(self.0.clone())
    }
}

// SAFETY:
// only drop or clone this on the main thread
unsafe impl<PortData> Send for ProcessPortOuter<PortData> {}

#[derive(Debug)]
pub(crate) struct ProcessPortInner<PortData> {
    pub ptr: PortPtr,
    data: RefCell<PortData>,
    buffer_lock: RefCell<()>,
}

#[derive(Debug)]
pub(crate) struct PortPtr {
    #[cfg(debug_assertions)]
    pub(crate) thread: std::thread::ThreadId,
    pub(crate) client: ClientHandle,
    pub(crate) port: NonNull<sys::jack_port_t>,
    pub(crate) flags: PortFlags,
    pub(crate) port_type: PortType,
}

impl PortPtr {
    pub unsafe fn new(
        client: ClientHandle,
        port: *mut sys::jack_port_t,
        flags: PortFlags,
        port_type: PortType,
    ) -> Option<Self> {
        Some(Self {
            #[cfg(debug_assertions)]
            thread: std::thread::current().id(),
            client,
            port: NonNull::new(port)?,
            flags,
            port_type,
        })
    }
}

impl Drop for PortPtr {
    fn drop(&mut self) {
        debug_assert_eq!(std::thread::current().id(), self.thread);
        unsafe {
            self.client
                .lib
                .jack_port_unregister(self.client.as_ptr(), self.port.as_ptr());
        }
    }
}

#[derive(Debug)]
pub(crate) struct ProcessPorts<PortData> {
    pub ports: HashMap<OwnedPortUuid, ProcessPortOuter<PortData>>,
}

impl<PortData> Default for ProcessPorts<PortData> {
    fn default() -> Self {
        Self {
            ports: HashMap::new(),
        }
    }
}
